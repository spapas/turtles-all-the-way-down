<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Logo Programming Environment</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Courier New', monospace;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }
        
        .header {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            padding: 1rem;
            color: white;
            text-align: center;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .container {
            display: flex;
            flex: 1;
            gap: 1rem;
            padding: 1rem;
            max-height: calc(100vh - 100px);
        }
        
        .editor-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 12px;
            padding: 1rem;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        }
        
        .canvas-panel {
            flex: 2;
            display: flex;
            flex-direction: column;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 12px;
            padding: 1rem;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        }
        
        .controls {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1rem;
            flex-wrap: wrap;
        }
        
        button {
            padding: 0.5rem 1rem;
            border: none;
            border-radius: 6px;
            background: #4f46e5;
            color: white;
            cursor: pointer;
            font-family: inherit;
            font-size: 0.9rem;
            transition: all 0.2s;
        }
        
        button:hover {
            background: #4338ca;
            transform: translateY(-1px);
        }
        
        button:active {
            transform: translateY(0);
        }
        
        .clear-btn {
            background: #ef4444;
        }
        
        .clear-btn:hover {
            background: #dc2626;
        }
        
        .speed-control {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .speed-control label {
            font-size: 0.9rem;
            color: #374151;
        }
        
        .speed-control input {
            width: 80px;
        }
        
        textarea {
            flex: 1;
            border: 2px solid #e5e7eb;
            border-radius: 6px;
            padding: 1rem;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            resize: none;
            outline: none;
            transition: border-color 0.2s;
        }
        
        textarea:focus {
            border-color: #4f46e5;
        }
        
        .canvas-container {
            flex: 1;
            border: 2px solid #e5e7eb;
            border-radius: 6px;
            position: relative;
            overflow: hidden;
            background: white;
        }
        
        canvas {
            display: block;
            cursor: crosshair;
        }
        
        .status {
            margin-top: 0.5rem;
            padding: 0.5rem;
            background: #f3f4f6;
            border-radius: 6px;
            font-size: 0.9rem;
            color: #374151;
        }
        
        .commands-help {
            margin-top: 1rem;
            padding: 1rem;
            background: #f9fafb;
            border-radius: 6px;
            font-size: 0.8rem;
            color: #4b5563;
            line-height: 1.4;
        }
        
        .commands-help h4 {
            margin-bottom: 0.5rem;
            color: #374151;
        }
        
        .turtle {
            position: absolute;
            width: 20px;
            height: 20px;
            transform-origin: center;
            transition: all 0.1s ease-out;
            z-index: 10;
            pointer-events: none;
            font-size: 30px;
        }
        
        .language-selector {
            margin-bottom: 1rem;
        }
        
        select {
            padding: 0.5rem;
            border: 2px solid #e5e7eb;
            border-radius: 6px;
            background: white;
            font-family: inherit;
        }
        
        .error {
            color: #ef4444;
            background: #fef2f2;
            border: 1px solid #fecaca;
            padding: 0.5rem;
            border-radius: 4px;
            margin-top: 0.5rem;
            font-size: 0.9rem;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>üê¢ Logo Programming Environment</h1>
        <p>Draw with code using turtle graphics</p>
    </div>
    
    <div class="container">
        <div class="editor-panel">
            <div class="language-selector">
                <label for="language">Language: </label>
                <select id="language">
                    <option value="en">English</option>
                    <option value="es">Espa√±ol</option>
                    <option value="fr">Fran√ßais</option>
                    <option value="de">Deutsch</option>
                    <option value="it">Italiano</option>
                </select>
            </div>
            
            <div class="controls">
                <button onclick="runCode()">‚ñ∂ Run</button>
                <button onclick="stepCode()">‚èØ Step</button>
                <button onclick="stopExecution()">‚èπ Stop</button>
                <button class="clear-btn" onclick="clearCanvas()">üóë Clear</button>
                <div class="speed-control">
                    <label>Speed:</label>
                    <input type="range" id="speed" min="1" max="10" value="5" onchange="updateSpeed()">
                </div>
            </div>
            
            <textarea id="code" placeholder="Enter your Logo commands here...">
# Try these commands:
forward 100
right 90
forward 100
right 90
forward 100
right 90
forward 100

# Draw a star
repeat 5 [
  forward 100
  right 144
]</textarea>
            
            <div class="status" id="status">Ready to run Logo commands</div>
            
            <div id="error" class="error" style="display: none;"></div>
            
            <div class="commands-help">
                <h4>Available Commands:</h4>
                <div id="help-text">
                    <strong>Movement:</strong> forward/fd, back/bk, left/lt, right/rt<br>
                    <strong>Pen:</strong> penup/pu, pendown/pd<br>
                    <strong>Control:</strong> repeat, home, clearscreen/cs<br>
                    <strong>Style:</strong> setcolor, setwidth<br>
                    <strong>Example:</strong> forward 50, right 90, repeat 4 [forward 50 right 90]
                </div>
            </div>
        </div>
        
        <div class="canvas-panel">
            <div class="canvas-container">
                <canvas id="canvas" width="600" height="400"></canvas>
                <div class="turtle" id="turtle">üê¢</div>
            </div>
        </div>
    </div>

    <script>
        // Turtle graphics engine
        class TurtleEngine {
            constructor(canvas) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.turtleElement = document.getElementById('turtle');
                this.reset();
                
                // Animation settings
                this.animationSpeed = 50; // ms between steps
                this.isAnimating = false;
                this.currentStep = 0;
                this.steps = [];
                this.animationId = null;
            }
            
            reset() {
                this.x = this.canvas.width / 2;
                this.y = this.canvas.height / 2;
                this.angle = 0; // 0 = up, 90 = right, 180 = down, 270 = left
                this.penIsDown = true;
                this.penColor = '#000000';
                this.penWidth = 2;
                this.updateTurtlePosition();
            }
            
            updateTurtlePosition() {
                const rect = this.canvas.getBoundingClientRect();
                const containerRect = this.canvas.parentElement.getBoundingClientRect();
                
                this.turtleElement.style.left = (this.x - 10) + 'px';
                this.turtleElement.style.top = (this.y - 10) + 'px';
                this.turtleElement.style.transform = `rotate(${this.angle + 90}deg)`;
            }
            
            forward(distance) {
                const radians = (this.angle - 90) * Math.PI / 180;
                const newX = this.x + distance * Math.cos(radians);
                const newY = this.y + distance * Math.sin(radians);
                
                if (this.penIsDown) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(this.x, this.y);
                    this.ctx.lineTo(newX, newY);
                    this.ctx.strokeStyle = this.penColor;
                    this.ctx.lineWidth = this.penWidth;
                    this.ctx.lineCap = 'round';
                    this.ctx.stroke();
                }
                
                this.x = newX;
                this.y = newY;
                this.updateTurtlePosition();
            }
            
            back(distance) {
                this.forward(-distance);
            }
            
            left(degrees) {
                this.angle -= degrees;
                this.updateTurtlePosition();
            }
            
            right(degrees) {
                this.angle += degrees;
                this.updateTurtlePosition();
            }
            
            penUp() {
                this.penIsDown = false;
            }
            
            penDown() {
                this.penIsDown = true;
            }
            
            home() {
                this.x = this.canvas.width / 2;
                this.y = this.canvas.height / 2;
                this.angle = 0;
                this.updateTurtlePosition();
            }
            
            clearScreen() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                this.home();
            }
            
            setColor(color) {
                const colors = {
                    'red': '#ff0000', 'green': '#00ff00', 'blue': '#0000ff',
                    'yellow': '#ffff00', 'cyan': '#00ffff', 'magenta': '#ff00ff',
                    'black': '#000000', 'white': '#ffffff', 'orange': '#ffa500',
                    'purple': '#800080', 'pink': '#ffc0cb', 'brown': '#a52a2a'
                };
                this.penColor = colors[color.toLowerCase()] || color;
            }
            
            setWidth(width) {
                this.penWidth = Math.max(1, Math.min(20, width));
            }
        }
        
        // Command localization
        const commandAliases = {
            en: {
                'forward': 'forward', 'fd': 'forward', 'back': 'back', 'bk': 'back',
                'left': 'left', 'lt': 'left', 'right': 'right', 'rt': 'right',
                'penup': 'penup', 'pu': 'penup', 'pendown': 'pendown', 'pd': 'pendown',
                'repeat': 'repeat', 'home': 'home', 'clearscreen': 'clearscreen', 'cs': 'clearscreen',
                'setcolor': 'setcolor', 'setwidth': 'setwidth'
            },
            es: {
                'adelante': 'forward', 'ad': 'forward', 'atras': 'back', 'at': 'back',
                'izquierda': 'left', 'iz': 'left', 'derecha': 'right', 'de': 'right',
                'subirlapiz': 'penup', 'sl': 'penup', 'bajarlapiz': 'pendown', 'bl': 'pendown',
                'repetir': 'repeat', 'casa': 'home', 'limpiar': 'clearscreen', 'li': 'clearscreen',
                'poncolor': 'setcolor', 'ponancho': 'setwidth',
                // English fallbacks
                'forward': 'forward', 'fd': 'forward', 'back': 'back', 'bk': 'back',
                'left': 'left', 'lt': 'left', 'right': 'right', 'rt': 'right',
                'penup': 'penup', 'pu': 'penup', 'pendown': 'pendown', 'pd': 'pendown',
                'repeat': 'repeat', 'home': 'home', 'clearscreen': 'clearscreen', 'cs': 'clearscreen',
                'setcolor': 'setcolor', 'setwidth': 'setwidth'
            },
            fr: {
                'avance': 'forward', 'av': 'forward', 'recule': 'back', 're': 'back',
                'gauche': 'left', 'ga': 'left', 'droite': 'right', 'dr': 'right',
                'levecrayon': 'penup', 'lc': 'penup', 'baissecrayon': 'pendown', 'bc': 'pendown',
                'repete': 'repeat', 'origine': 'home', 'efface': 'clearscreen', 'ef': 'clearscreen',
                'fixecouleur': 'setcolor', 'fixelargeur': 'setwidth',
                // English fallbacks
                'forward': 'forward', 'fd': 'forward', 'back': 'back', 'bk': 'back',
                'left': 'left', 'lt': 'left', 'right': 'right', 'rt': 'right',
                'penup': 'penup', 'pu': 'penup', 'pendown': 'pendown', 'pd': 'pendown',
                'repeat': 'repeat', 'home': 'home', 'clearscreen': 'clearscreen', 'cs': 'clearscreen',
                'setcolor': 'setcolor', 'setwidth': 'setwidth'
            },
            de: {
                'vorwaerts': 'forward', 'vw': 'forward', 'rueckwaerts': 'back', 'rw': 'back',
                'links': 'left', 'li': 'left', 'rechts': 'right', 'rt': 'right',
                'stifthoch': 'penup', 'sh': 'penup', 'stiftrunter': 'pendown', 'sr': 'pendown',
                'wiederhole': 'repeat', 'startpos': 'home', 'loesche': 'clearscreen', 'ls': 'clearscreen',
                'setzefarbe': 'setcolor', 'setzebreite': 'setwidth',
                // English fallbacks
                'forward': 'forward', 'fd': 'forward', 'back': 'back', 'bk': 'back',
                'left': 'left', 'lt': 'left', 'right': 'right', 'rt': 'right',
                'penup': 'penup', 'pu': 'penup', 'pendown': 'pendown', 'pd': 'pendown',
                'repeat': 'repeat', 'home': 'home', 'clearscreen': 'clearscreen', 'cs': 'clearscreen',
                'setcolor': 'setcolor', 'setwidth': 'setwidth'
            },
            it: {
                'avanti': 'forward', 'av': 'forward', 'indietro': 'back', 'in': 'back',
                'sinistra': 'left', 'si': 'left', 'destra': 'right', 'de': 'right',
                'alzapenna': 'penup', 'ap': 'penup', 'abbassapenna': 'pendown', 'ab': 'pendown',
                'ripeti': 'repeat', 'casa': 'home', 'pulisci': 'clearscreen', 'pu': 'clearscreen',
                'impostacolore': 'setcolor', 'impostalarghezza': 'setwidth',
                // English fallbacks
                'forward': 'forward', 'fd': 'forward', 'back': 'back', 'bk': 'back',
                'left': 'left', 'lt': 'left', 'right': 'right', 'rt': 'right',
                'penup': 'penup', 'pu': 'penup', 'pendown': 'pendown', 'pd': 'pendown',
                'repeat': 'repeat', 'home': 'home', 'clearscreen': 'clearscreen', 'cs': 'clearscreen',
                'setcolor': 'setcolor', 'setwidth': 'setwidth'
            }
        };
        
        // Help text translations
        const helpTexts = {
            en: `<strong>Movement:</strong> forward/fd, back/bk, left/lt, right/rt<br>
                 <strong>Pen:</strong> penup/pu, pendown/pd<br>
                 <strong>Control:</strong> repeat, home, clearscreen/cs<br>
                 <strong>Style:</strong> setcolor, setwidth<br>
                 <strong>Example:</strong> forward 50, right 90, repeat 4 [forward 50 right 90]`,
            es: `<strong>Movimiento:</strong> adelante/ad, atras/at, izquierda/iz, derecha/de<br>
                 <strong>L√°piz:</strong> subirlapiz/sl, bajarlapiz/bl<br>
                 <strong>Control:</strong> repetir, casa, limpiar/li<br>
                 <strong>Estilo:</strong> poncolor, ponancho<br>
                 <strong>Ejemplo:</strong> adelante 50, derecha 90, repetir 4 [adelante 50 derecha 90]`,
            fr: `<strong>Mouvement:</strong> avance/av, recule/re, gauche/ga, droite/dr<br>
                 <strong>Crayon:</strong> levecrayon/lc, baissecrayon/bc<br>
                 <strong>Contr√¥le:</strong> repete, origine, efface/ef<br>
                 <strong>Style:</strong> fixecouleur, fixelargeur<br>
                 <strong>Exemple:</strong> avance 50, droite 90, repete 4 [avance 50 droite 90]`,
            de: `<strong>Bewegung:</strong> vorwaerts/vw, rueckwaerts/rw, links/li, rechts/rt<br>
                 <strong>Stift:</strong> stifthoch/sh, stiftrunter/sr<br>
                 <strong>Kontrolle:</strong> wiederhole, startpos, loesche/ls<br>
                 <strong>Stil:</strong> setzefarbe, setzebreite<br>
                 <strong>Beispiel:</strong> vorwaerts 50, rechts 90, wiederhole 4 [vorwaerts 50 rechts 90]`,
            it: `<strong>Movimento:</strong> avanti/av, indietro/in, sinistra/si, destra/de<br>
                 <strong>Penna:</strong> alzapenna/ap, abbassapenna/ab<br>
                 <strong>Controllo:</strong> ripeti, casa, pulisci/pu<br>
                 <strong>Stile:</strong> impostacolore, impostalarghezza<br>
                 <strong>Esempio:</strong> avanti 50, destra 90, ripeti 4 [avanti 50 destra 90]`
        };
        
        // Logo parser and interpreter
        class LogoParser {
            constructor(turtle, language = 'en') {
                this.turtle = turtle;
                this.language = language;
                this.aliases = commandAliases[language];
            }
            
            setLanguage(language) {
                this.language = language;
                this.aliases = commandAliases[language];
            }
            
            parse(code) {
                // Remove comments
                const lines = code.split('\n').map(line => 
                    line.split('#')[0].trim()
                ).filter(line => line.length > 0);
                
                const tokens = [];
                for (const line of lines) {
                    tokens.push(...this.tokenize(line));
                }
                
                return this.parseTokens(tokens);
            }
            
            tokenize(line) {
                const tokens = [];
                let current = '';
                let inBrackets = false;
                
                for (let i = 0; i < line.length; i++) {
                    const char = line[i];
                    
                    if (char === '[') {
                        if (current.trim()) {
                            tokens.push(current.trim());
                            current = '';
                        }
                        inBrackets = true;
                        tokens.push('[');
                    } else if (char === ']') {
                        if (current.trim()) {
                            tokens.push(current.trim());
                            current = '';
                        }
                        inBrackets = false;
                        tokens.push(']');
                    } else if (char === ' ' || char === '\t') {
                        if (current.trim()) {
                            tokens.push(current.trim());
                            current = '';
                        }
                    } else {
                        current += char;
                    }
                }
                
                if (current.trim()) {
                    tokens.push(current.trim());
                }
                
                return tokens;
            }
            
            parseTokens(tokens) {
                const commands = [];
                let i = 0;
                
                while (i < tokens.length) {
                    const result = this.parseCommand(tokens, i);
                    if (result.command) {
                        commands.push(result.command);
                    }
                    i = result.nextIndex;
                }
                
                return commands;
            }
            
            parseCommand(tokens, startIndex) {
                if (startIndex >= tokens.length) {
                    return { command: null, nextIndex: startIndex + 1 };
                }
                
                const token = tokens[startIndex].toLowerCase();
                const command = this.aliases[token];
                
                if (!command) {
                    throw new Error(`Unknown command: ${tokens[startIndex]}`);
                }
                
                switch (command) {
                    case 'forward':
                    case 'back':
                    case 'left':
                    case 'right':
                    case 'setwidth':
                        if (startIndex + 1 >= tokens.length) {
                            throw new Error(`${command} requires a number`);
                        }
                        const value = parseFloat(tokens[startIndex + 1]);
                        if (isNaN(value)) {
                            throw new Error(`${command} requires a valid number`);
                        }
                        return {
                            command: { type: command, value: value },
                            nextIndex: startIndex + 2
                        };
                    
                    case 'setcolor':
                        if (startIndex + 1 >= tokens.length) {
                            throw new Error(`setcolor requires a color`);
                        }
                        return {
                            command: { type: 'setcolor', value: tokens[startIndex + 1] },
                            nextIndex: startIndex + 2
                        };
                    
                    case 'penup':
                    case 'pendown':
                    case 'home':
                    case 'clearscreen':
                        return {
                            command: { type: command },
                            nextIndex: startIndex + 1
                        };
                    
                    case 'repeat':
                        if (startIndex + 1 >= tokens.length) {
                            throw new Error(`repeat requires a number`);
                        }
                        const count = parseInt(tokens[startIndex + 1]);
                        if (isNaN(count)) {
                            throw new Error(`repeat requires a valid number`);
                        }
                        
                        if (startIndex + 2 >= tokens.length || tokens[startIndex + 2] !== '[') {
                            throw new Error(`repeat requires commands in brackets [ ]`);
                        }
                        
                        const blockResult = this.parseBlock(tokens, startIndex + 3);
                        return {
                            command: { type: 'repeat', count: count, commands: blockResult.commands },
                            nextIndex: blockResult.nextIndex
                        };
                    
                    default:
                        throw new Error(`Unhandled command: ${command}`);
                }
            }
            
            parseBlock(tokens, startIndex) {
                const commands = [];
                let i = startIndex;
                let bracketLevel = 1;
                
                while (i < tokens.length && bracketLevel > 0) {
                    if (tokens[i] === '[') {
                        bracketLevel++;
                    } else if (tokens[i] === ']') {
                        bracketLevel--;
                        if (bracketLevel === 0) {
                            break;
                        }
                    }
                    
                    if (bracketLevel === 1) {
                        const result = this.parseCommand(tokens, i);
                        if (result.command) {
                            commands.push(result.command);
                        }
                        i = result.nextIndex;
                    } else {
                        i++;
                    }
                }
                
                if (bracketLevel > 0) {
                    throw new Error(`Missing closing bracket ]`);
                }
                
                return { commands: commands, nextIndex: i + 1 };
            }
            
            execute(commands) {
                const steps = [];
                this.generateSteps(commands, steps);
                return steps;
            }
            
            generateSteps(commands, steps) {
                for (const command of commands) {
                    switch (command.type) {
                        case 'forward':
                            steps.push(() => this.turtle.forward(command.value));
                            break;
                        case 'back':
                            steps.push(() => this.turtle.back(command.value));
                            break;
                        case 'left':
                            steps.push(() => this.turtle.left(command.value));
                            break;
                        case 'right':
                            steps.push(() => this.turtle.right(command.value));
                            break;
                        case 'penup':
                            steps.push(() => this.turtle.penUp());
                            break;
                        case 'pendown':
                            steps.push(() => this.turtle.penDown());
                            break;
                        case 'home':
                            steps.push(() => this.turtle.home());
                            break;
                        case 'clearscreen':
                            steps.push(() => this.turtle.clearScreen());
                            break;
                        case 'setcolor':
                            steps.push(() => this.turtle.setColor(command.value));
                            break;
                        case 'setwidth':
                            steps.push(() => this.turtle.setWidth(command.value));
                            break;
                        case 'repeat':
                            for (let i = 0; i < command.count; i++) {
                                this.generateSteps(command.commands, steps);
                            }
                            break;
                    }
                }
            }
        }
        
        // Global variables
        let turtle;
        let parser;
        let isRunning = false;
        let currentStepIndex = 0;
        let executionSteps = [];
        
        // Initialize
        window.addEventListener('load', () => {
            const canvas = document.getElementById('canvas');
            const container = canvas.parentElement;
            
            // Make canvas responsive
            function resizeCanvas() {
                const rect = container.getBoundingClientRect();
                canvas.width = rect.width - 2;
                canvas.height = rect.height - 2;
                if (turtle) {
                    turtle.reset();
                }
            }
            
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            
            turtle = new TurtleEngine(canvas);
            parser = new LogoParser(turtle, 'en');
            
            updateStatus('Ready to run Logo commands');
            
            // Language change handler
            document.getElementById('language').addEventListener('change', (e) => {
                const lang = e.target.value;
                parser.setLanguage(lang);
                document.getElementById('help-text').innerHTML = helpTexts[lang];
                updateStatus(`Language changed to ${lang}`);
            });
        });
        
        // Control functions
        function runCode() {
            if (isRunning) {
                updateStatus('Already running! Stop first.');
                return;
            }
            
            const code = document.getElementById('code').value;
            hideError();
            
            try {
                const commands = parser.parse(code);
                executionSteps = parser.execute(commands);
                currentStepIndex = 0;
                isRunning = true;
                
                updateStatus(`Running ${executionSteps.length} steps...`);
                executeNextStep();
            } catch (error) {
                showError(error.message);
                updateStatus('Error in code');
            }
        }
        
        function executeNextStep() {
            if (!isRunning || currentStepIndex >= executionSteps.length) {
                isRunning = false;
                updateStatus('Execution complete');
                return;
            }
            
            try {
                executionSteps[currentStepIndex]();
                currentStepIndex++;
                
                updateStatus(`Step ${currentStepIndex}/${executionSteps.length}`);
                
                setTimeout(executeNextStep, turtle.animationSpeed);
            } catch (error) {
                isRunning = false;
                showError(error.message);
                updateStatus('Runtime error');
            }
        }
        
        function stepCode() {
            if (!executionSteps.length) {
                const code = document.getElementById('code').value;
                hideError();
                
                try {
                    const commands = parser.parse(code);
                    executionSteps = parser.execute(commands);
                    currentStepIndex = 0;
                    updateStatus(`Ready to step through ${executionSteps.length} commands`);
                } catch (error) {
                    showError(error.message);
                    updateStatus('Error in code');
                    return;
                }
            }
            
            if (currentStepIndex < executionSteps.length) {
                try {
                    executionSteps[currentStepIndex]();
                    currentStepIndex++;
                    updateStatus(`Step ${currentStepIndex}/${executionSteps.length}`);
                    
                    if (currentStepIndex >= executionSteps.length) {
                        updateStatus('Stepping complete');
                        executionSteps = [];
                    }
                } catch (error) {
                    showError(error.message);
                    updateStatus('Runtime error');
                }
            } else {
                updateStatus('No more steps');
            }
        }
        
        function stopExecution() {
            isRunning = false;
            executionSteps = [];
            currentStepIndex = 0;
            updateStatus('Execution stopped');
        }
        
        function clearCanvas() {
            turtle.clearScreen();
            stopExecution();
            updateStatus('Canvas cleared');
        }
        
        function updateSpeed() {
            const speed = document.getElementById('speed').value;
            turtle.animationSpeed = 110 - (speed * 10); // Invert: higher value = faster
        }
        
        function updateStatus(message) {
            document.getElementById('status').textContent = message;
        }
        
        function showError(message) {
            const errorElement = document.getElementById('error');
            errorElement.textContent = message;
            errorElement.style.display = 'block';
        }
        
        function hideError() {
            document.getElementById('error').style.display = 'none';
        }
    </script>
</body>
</html>